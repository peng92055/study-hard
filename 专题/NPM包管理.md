# NPM包管理机制
  - 早期npm版本中，npm处理依赖方式简单粗暴，以递归的形式安装所有依赖。
  - npm 3.x版本之后更新为扁平结构。优先安装在node_modules根目录。当新的依赖版本不符合已有包的版本规则，则放在当前包下的node_modules下。
  - npm 5.x版本增加package-lock.json。用于锁定依赖结构。
  - 版本的格式 major.minor.patch 主版本.次版本.修补版本号
  - 版本匹配规则
    - 锁定版本 1.1.2
    - 可以大于或等于某个版本  >=1.1.2
    - 可以小于某个版本 <1.1.2
    - 指定范围 1.2.2-2.2.1 相当于 >=1.2.2 <2.2.1
    - 大概匹配某个版本 ~1.1.2
      - ~1.1.2指定修补版本，则必须大于修补版本 相当于是 >=1.1.2 <1.2.0
      - ~1.1指定次版本，则次版本不变，修复版本任意 相当于是1.1.n (>=1.1.0 && <1.2.0)
      - ~1指定主版本，则主版本不变，后续任意 相当于1.n (>=1.0.0&<2.0.0)
    - 兼容某个版本
      - 版本号中最左边的非0数字的右侧可以是任意
      - 如果缺少某个版本号，则这个版本号的位置可以是任意
      - ^1.1.2 表示>=1.1.2 <2.0.0
      - ^0.2.3 表示>=0.2.3 <0.3.0
      - ^0.0 表示>=0.0.0 <0.1.0
    - 标识符1.2.x 表示修补版本可以任意

## npm install后发生了什么
  - 执行npm工程自身的preinstall,如果当前npm工程定义了preinstall钩子，则会被优先执行
  - 确定首层依赖模块
    - 也就是确定dependencies和devDependencies属性中的直接指定的模块
    - 工程本身是整个依赖树的根节点，每个首层依赖模块都是根节点下面的一颗子树，npm会开启多进程从每个首层依赖模块开始逐步寻找更深层次的节点。
  - 获取模块（是一个递归的过程）
    - 获取模块信息，优先查找package-lock.json中指定的包地址，如果没有则从仓库中获取。如package.json中某个包是^1.1.2。则去仓库获取符合1.x.x的最新版本
    - 获取模块实体。通过上一步的模块信息中的地址，检查本地是否有缓存，没有则从仓库下载
    - 查找该版本依赖，有则回到第一步继续获取依赖的版本信息，没有则停止

### 参考
- [https://zhuanlan.zhihu.com/p/128625669]
- [https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/22]