## 垃圾回收
  - 可达性
    - V8引擎采用的是可达性算法来判断堆中的对象应不应该被回收
      - 从根节点出发，遍历所有对象
      - 可以遍历到的对象，是可达的
      - 没有被遍历到的对象，是不可达的
    - 在浏览器中，根节点有很多。主要包括：
      - 全局变量window,位于每个iframe中
      - 文档DOM树
      - 存放在栈上的变量

## 回收的两种策略
  - 标记清除
    - 对所有不可达的对象进行标记，回收不可达的值所占据的内存
  - 引用计数



### 面试总结
  - 浏览器怎么进行垃圾回收？
    - 什么是垃圾
      - 不再需要，即为垃圾。一般来说没有被引用的对象就是垃圾，如果几个对象引用形成一个环，互相引用，但是根访问不到它们，则也是垃圾。
      - 全局变量随时可能用到，所以一定不是垃圾
    - 如何捡垃圾（遍历算法）
      - 两种策略： 标记清除和引用计数。常用标记清除法。
      - 标记空间中（可达）值
      - 回收不可达的值占用的内存
      - 做内存整理
    - 什么时候捡垃圾
      - 垃圾回收的时候回造成页面卡顿
      - 分代收集、增量收集、闲时收集
        - 分代收集： 将堆分为新生代与老生代，多回收新生代，少回收老生代
        - 增量收集： 将垃圾收集工作分为更小的块，每次处理一部分，多次处理
        - 闲时收集： 在cpu空闲时尝试运行
  - 浏览器中不同类型变量的内存都是何时释放？
    - js中的类型分为值类型和引用类型。
      - 引用类型再没有被引用后，就通过v8自动回收
      - 值类型：
        - 如果处于闭包的情况下，要等闭包没有引用才会被v8回收
        - 非闭包的情况下，等待v8的新生代切换的时候回收
  
  - 哪些情况会导致内存泄露？如何避免？
    - 内存泄露是用不到、访问不到的变量，依然占据着内存空间，不能被再次利用起来。
    - 在vue中，有以下情况可能发生内存泄露
      - 监听在window/body等事件没有解绑
      - 绑在EventBus的事件没有解绑
      - Vuex的$store,watch了之后没有unwatch
      - 使用第三方库创建，没有调用正确的销毁函数
    - 解决方法： beforeDestory中及时销毁
      - 绑定了DOM/BOM对象中的时间加removeEventListener
      - 观察者模式中加$off
      - 如果组件中是使用了定时器，应销毁处理
      - 使用弱引用weakMap,weakSet
  
  - 闭包会导致内存泄露吗？
    - **不会**
    - 闭包里面的变量就是我们需要的变量，不能说是内存泄露。
    - 只是因为IE早期版本，在使用闭包之后依然回收不了闭包里面的引用变量，这是IE的bug。不是闭包的问题。

  - weakMap,weakSet和Map,Set有什么区别？
    - Set和Map主要的使用场景在于数据重组和数据存储。
    - Set是一种叫做**集合**的数据结构，Map是一种叫做**字典**的数据结构
    - Set类似于数组，成员是唯一的，没有重复的值。
      - 常用方法：add,delete,has,clear。keys(),values(),entrys(),forEach()
      - 属性： size
    - WeakSet对象允许将弱引用对象存放在集合中。与Set的区别在于：
      - WeakSet只能存放对象引用，不能存放值。而Set都可以。
      - WeakSet中对象值都是的弱引用，垃圾回收机制不考虑该引用。如果该对象没有被其他地方引用，则WeakSet对象的成员元素的数量取决于垃圾回收机制有没有运行。
      - WeakSet不能遍历，不支持key(),value()等方法。不支持size属性。
    - Map是一种存放键值对的集合，其中键和值都可以是任何数据类型。
      - 常用方法： set(),delete(),get(),delete(),has(),clear()。
      - 属性：size
    - WeakMap是弱引用Map集合。
      - 键必须是对象
      - 垃圾回收机制会不考虑它的引用。
      - 支持set(),get()，has(),delete()。不支持size属性和遍历相关的方法。


    - 在ES6中，新增的WeakMap和WeakSet，就是为了解决内存泄露的问题。
    - 它的键名所引用的对象都是弱引用，就是垃圾回收机制遍历的时候不考虑该引用。

- 参考文档： [https://mp.weixin.qq.com/s/hpMGNtHPN_T-Upg9V4L_Jg]
  - https://segmentfault.com/a/1190000018605776
  - http://newhtml.net/v8-garbage-collection/
  - https://www.jianshu.com/p/a8a04fd00c3c