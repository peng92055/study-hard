# 从一个url到页面展示的全流程

## 浏览器接收URL 到 开启网络请求线程
  - 浏览器是多进程的，有一个主控进程，以及每一个tab页面会开启一个进程（某些情况下多tab会合并进程，比如打开多个空白页）
  - 每个tab页面可以看做是一个浏览器的渲染进程（内核进程），这个进程是多线程的
  - 一个进程分为5大类线程
    1. GUI渲染线程 
      - 负责浏览器渲染，如html、css解析，构建dom树和绘制树，布局和绘制等。
      - GUI线程与JS互斥，当JS引擎执行时，GUI线程就会被挂起，GUI的更新会保存在一个队列中等待JS引擎空闲时立即执行。
    2. JS引擎线程
      - 也称js内核，负责解析JS脚本并运行。
    3. 事件触发线程
      - 负责控制事件循环。当js引擎遇到异步任务（settimeout、promise、ajax等）时，就将这些任务添加到事件线程中，当对应的任务符合触发条件时，该线程会把事件添加到待处理的任务队列（Event Quene）的队尾，等待JS引擎处理。
    4. 定时器线程
      - 负责setTimeout和setInterval的线程。通过单独的线程来进行计时并触发才不会影响计时的准确，因为js引擎是单线程，如果处于阻塞状态就会影响计时的准确。
    5. 异步请求线程
      - 负责XMLHttpRequest请求的线程。当请求状态变更，就会将回调函数放入事件队列中等待JS引擎执行。
    - HTML5 新增web worker线程
      - 由JS引擎线程向浏览器发起申请一个独立线程，由主线程完全控制，但是不能操作dom。两个线程不会互相阻塞，只能通过postMessage来通信。通信的数据经过了序列化，传递的是值而不是引用，故而数据更改不会相互影响。
  - 输入URL后，浏览器会解析，开启网络请求线程
  
## 开启网络请求线程 到 发出一个完整的HTTP请求
  - 地址解析： 判断是合法的URL还是待搜索的关键词，并且根据输入的内容进行自动填充、字符编码等操作
  - 浏览器使用HSTS（HTTP Strict Transport Security）强制客户端使用HTTPS访问页面
  - 浏览器的安全监测、访问限制
  - 检查请求缓存，查看浏览器是否有缓存
  - DNS查询
    - 浏览器缓存 -> 操作系统缓存（hosts文件） -> 路由器缓存 -> DNS服务器缓存 -> 根域名服务器缓存
    - dns-prefetch优化,在html标签中加入<link rel="dns-prefetch" href="//domain.com"> 进行域名预解析
    - 通过DNS解析得到域名对应的IP地址
  - 应用层：发送HTTP请求，携带http报文（请求报头和主体）
  - 传输层：TCP传输报文。向服务端发起TCP连接，建立连接前会进行TCP三次握手。
    - 三次握手：
      ```
        客户端：hello，你是server么？
        服务端：hello，我是server，你是client么
        客户端：yes，我是client
      ``` 
    - get和post虽然本质都是tcp/ip，但两者除了在http层面外，在tcp/ip层面也有区别。get会产生一个tcp数据包，post两个
  - 网络层： IP协议查询Mac地址
  - 数据链路层：根据以太网协议将数据分为以“帧”为单位的数据包
  - 物理传输层： 利用物理介质传输比特流

## 服务器接收到请求 到 对应后台服务接收到请求
  - 数据传输到服务器（常见的apache和nginx），会监听得到请求，开启一个子进程来处理。这里服务器可能是集群，会经历负载均衡。
  - 请求到分配后的容器服务器，处理请求，接收TCP报文后，会对连接进行处理，对http协议进行解析，并进行安全验证
  - 查看URL重写规则，如果请求的文件是真实存在的，比如图片、html、css、js文件等，会直接返回这个文件
  - 如果是服务器的接口服务，则进入java应用服务，开始处理,mvc,最终返回响应
## 浏览器接收http响应数据包后的解析
  - 浏览器接收到来自服务器的响应资源后，会对资源进行分析。
  - 查看response header,根据不同的状态码做相应的反馈。如果响应资源做了gzip压缩，还需要进行解压。
  - 查看响应资源的缓存返回机制做响应的处理。
  - 根据响应资源里的MIME(媒体类型)解析响应的内容，这里以HTML返回为例
## HTML解析构建
  - 浏览器的解析是从上往下逐行解析。
  - 解码：浏览器接收到二进制流，浏览器根据文件执行编码方式（utf-8）进行encoding解码转成字符串流。
  - 符号化（tokenization）: 将字符串流解析成符号token，html符号包括开始标签、结束标签、属性名和属性值。它是通过一个状态机来识别符号的状态。
  - 构建DOM树: 通过符号化得到的标记token,最终生成DOM树。
  - 当整个解析的过程完成以后，浏览器会通过DOMContentLoaded事件来通知DOM解析完成。
## CSS解析和JS解析执行及绘制
  - CSS的加载不会影响DOM树的解析，会阻塞render树的渲染。css的加载会阻塞JS的语句执行。
  - JS的加载和执行会阻塞DOM树的解析和渲染。因为JS可能会动态操作DOM。可以通过异步的方式加载脚本。 defer是延迟执行，而async是异步执行。
  - 原则： CSS资源放在JS资源前，一般放在head，JS资源放在HTML最底部，也就是</body>之前
  - 在解析DOM的同时，当遇到外部资源时会放到下载队列，会由单独的异步线程下载资源。
  - CSS资源加载完成，会和DOM解析同步解析成CSSOM树。
  - 构建渲染树：render Tree
    - 当DOM树和CSSOM树都建立完后，开始进行合并，也就是渲染树。
    - 渲染树会忽略不需要渲染的节点，例如：display:none的节点。所以渲染树和DOM树不是严格的一一对应。
  - 布局layout和绘制paint：确定渲染树所有节点的几何属性，通过元素的盒模型生成相应的位图。
  - 合并绘制：将所有的位图合并成一个图片展示在显示屏上。
  - 重排（回流reflow）当浏览器发现某个部门发现变化影响布局时，需要从html标签开始递归往下，重新计算位置和大小。例如：滑动鼠标、resize窗口都会发生变化。重排一定会引起重绘。
  - 重绘：当改变了某个元素的背景色、文字颜色等不影响位置和大小的变化，就会触发重绘。每次重绘后，浏览器还需要合并渲染层并输出到屏幕上。
  - 回流的成本比重绘高很多，所以我们尽量避免回流。
  - display:none会触发回流，而visiblity:hidden只会触发重绘。
## JS引擎解析过程
  - 一阶段： 语法解析 -> 词法单元 -> 抽象语法树（AST） -> 机器指令
  - 二阶段： 预处理 -> 运行环境 -> 函数调用栈 -> 执行上下文
  - 三阶段： 执行 -> 事件循环
    - -> 宏任务
    - -> 微任务
## css的可视化格式模型
  - css中规定每一个元素都有自己的盒子模型
  - 可视化格式模型则是规定如何将这些盒子布局及相互作用
  - **可视化格式模型：浏览器按照一定规则对文档树进行可视化处理**
  - 包含：包含块，控制框，BFC，IFC，定位体系，浮动等
## 其他



- 扩展
  - 浏览器是多进程的，浏览器内核是多线程的，JS引擎是单线程的
  - 进程是CPU资源分配的最小单元，线程是CPU调度的最小单元
  - DomContentLoad和load
    - DomContentLoad触发，仅当dom加载完成，不包括css和图片或者异步的js加载完成
    - load事件触发，页面上所有的dom、css、脚本和图片都已经加载完了。
  - 重排(因为是流式布局，也称回流)、重绘 [https://blog.csdn.net/lixiaosenlin/article/details/108262343]

- 参考
  - [https://zhuanlan.zhihu.com/p/34453198]
  - [https://zhuanlan.zhihu.com/p/80551769]
  - [https://segmentfault.com/a/1190000012925872]