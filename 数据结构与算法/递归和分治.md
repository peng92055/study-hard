# 递归和分治
## 递归本身是一个循环，但不是for循环，而是通过函数调用自身的循环。
  - 有重复子问题是需要优化，尾递归优化等
eg: 计算n! 或者斐波拉契函数
  ```
  function factorial(n) {
    if(n === 1) {
      return n
    }
    
    return n * factorial(n-1)
  }
  factorial(5)

  //尾递归优化  将函数结果传入下一个函数中
  function factorial(n, total) {
    if(n === 0 || n === 1) return total;
    return factorial(n-1, n * total)
  }
  ``` 
eg: 斐波拉契函数
  ```
  // 斐波拉契函数
  function fib(n) {
    if(n === 0 || n === 1) {
      return n
    }
    return fib(n-1) + fib(n-2)
  }
  fib(5)
  //缓存数据
  function fib(n) {
    let cache = {};
    let fun = function (n) {
      if(cache[n]) return cache[n];
      if(n === 0 || n === 1) return n;
      return fun(n-1) + fun(n-2);
    }
    return fun(n)
  }
  ```
## 分治 Divde & Conquer （庖丁解牛）
  - 没有中间子问题和大量重复计算时使用
eg: 计算x的n次方 letcode 21
  - 调用库函数 pow(x, n)
  - 暴力乘法 时间复杂度是O(n)
  - 分治 时间复杂度O(logn)  以2为底数
    ```
      var myPow = function(x, n) {
        if(n === 0) {
          return 1
        }
        if(n < 0) {
          return 1 / myPow(x, -n)
        }
        if(n % 2 === 1) {
          //奇数次方
          return x * myPow(x,n - 1)
        }
        //偶数次方
        return myPow(x*x, n / 2)
      }
    ```
  - 位运算 


## 贪心算法（“只看眼前，目光短浅”）Greedy
- 在对问题求解时，总是做出在当前看来是最好的选择。但是在最后不一定是最优。
- eg: 用1/5/10/20/50 来配出36元,求出纸币数最少的。
- 贪心算法的场景要求：
  - 问题能够分解成子问题解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解成为最优子问题。
  - 当贪心算法不能解决时，就用动态规划
  - 贪心算法与动态规划不同在于它对每个子问题的解决方案都做出选择，不能回退。
  - 动态规划则会保存以前的运算的结果，并根据以前的结果对当前进项选择，有回退功能。
- letcode 122 股票买卖最佳时机
  - DFS 时间复杂度o(2**n)
  - Greedy 时间复杂度o(n)
  - DP 动态规划 时间复杂度o(n)
  
